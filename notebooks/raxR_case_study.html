<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Grace Patlewicz">

<title>raxR case study</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="raxR_case_study_files/libs/clipboard/clipboard.min.js"></script>
<script src="raxR_case_study_files/libs/quarto-html/quarto.js"></script>
<script src="raxR_case_study_files/libs/quarto-html/popper.min.js"></script>
<script src="raxR_case_study_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="raxR_case_study_files/libs/quarto-html/anchor.min.js"></script>
<link href="raxR_case_study_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="raxR_case_study_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="raxR_case_study_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="raxR_case_study_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="raxR_case_study_files/libs/bootstrap/bootstrap-cdc474169d40208b0743bf9617ddced0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">raxR case study</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Grace Patlewicz </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="making-acute-oral-toxicity-read-across-predictions" class="level2">
<h2 class="anchored" data-anchor-id="making-acute-oral-toxicity-read-across-predictions">Making Acute Oral Toxicity Read-Across Predictions</h2>
<p>Read-across is a well established data gap filling technique used within analogue and category approaches. This approach relies on a chemical with existing data values, known as the source analogue, being used to make a prediction for a ‘similar’ chemical, the target, that lacks that same property information. Typically the source analogue and target substance are structurally similar. However the justification of the similarity with respect to the property of interest relies on more than just structural similarity, other considerations such as similarity in physicochemical profile, mechanistic profile, metabolism profile etc also play a role. This case study will consider how a read-across is undertaken from the perspective of identifying candidate analogues on the basis of structural similarity (analogue identification), evaluating those analogues from both a structural and physicochemical perspective before making a read-across prediction. The prediction itself will rely on the Generalised Read-Across (GenRA) approach whereby a similarity weighted toxicity calculation is performed. The toxicity endpoint of interest in this example is focused on acute oral toxicity, specifically the estimates of the dose that causes lethality in rats after a single exposure. The dataset used for this case study was previously used in the TAME modules. It was originally compiled and published in the following manuscript: Helman G, Shah I, Patlewicz G. Transitioning the Generalised Read-Across approach (GenRA) to quantitative predictions: A case study using acute oral toxicity data. Comput Toxicol. 2019 Nov 1;12(November 2019):10.1016/j.comtox.2019.100097. doi: 10.1016/j.comtox.2019.100097. PMID: <a href="https://pubmed.ncbi.nlm.nih.gov/33623834/">33623834</a>.</p>
</section>
<section id="case-study" class="level2">
<h2 class="anchored" data-anchor-id="case-study">Case study</h2>
<p>The case study will illustrate how to make read-across predictions for the same chemical using 2 ways. Initially, a minimal R Shiny App will be used to make acute oral toxicity prediction of the following compound 4-tert-Butylcyclohexyl prop-2-enoate (DTXSID001004378, SMILES: CC(C)CCCCCCCCCCC(=O)OCC(O)CO. The same predictions using the raxR package that underpins the R Shiny App will also be used.</p>
</section>
<section id="running-the-minimal-r-shiny-app" class="level2">
<h2 class="anchored" data-anchor-id="running-the-minimal-r-shiny-app">Running the minimal R Shiny App</h2>
<p>When launched the app is structured in 4 distinct browser tabs. The first tab provides an overview of the acute toxicity dataset, both in terms of the distribution of log molar acute LD50 values as well as a tabulation of all the values with their chemical identifier expressed as a dtxsid (the Distributed Structure Searchable Toxicity Database Substance Identifier or DSSTox Substance Identifier).</p>
<ul>
<li>What do you notice about the distribution of the acute lethality values?</li>
<li>What is the range of spread of values?</li>
</ul>
</section>
<section id="analogue-id" class="level2">
<h2 class="anchored" data-anchor-id="analogue-id">Analogue ID</h2>
<p>In moving to the second tab, the first step of the read-across workflow can be initiated. Herein the target chemical of interest will be inserted into the relevant text boxes to capture 1) the SMILES, the 1D structural representation of the target chemical and 2) the dtxsid as identifier. The third field is the number of source analogues to return. As a default, the number of source analogues will be kept at 10 given the size of the acute lethality dataset.</p>
<ol type="1">
<li>Copy/Paste the identifier and SMILES values provided.</li>
</ol>
<p>DTXSID001004378, SMILES: CC(C)CCCCCCCCCCC(=O)OCC(O)CO</p>
<ul>
<li>What happens?</li>
</ul>
<p>Below the text field boxes, a table is now presented which shows the 10 closest source analogues on the basis of structural similarity and what their pairwise similarity is. The sim score is the Tanimoto similarity on the basis of circular fingerprints calculated using the Rcdk package.</p>
<p>Behind the scenes, chemical fingerprints are generated for the target chemical, then a pairwise similarity calculation is performed to return the 10 source analogues with the highest similarity scores.</p>
<ul>
<li>What do you notice about the scores? What impact do these scores have on the prediction being generated?</li>
</ul>
</section>
<section id="physicochemical-profile" class="level2">
<h2 class="anchored" data-anchor-id="physicochemical-profile">Physicochemical profile</h2>
<p>One of the considerations that is important in evaluating the suitability of the source analogues is how they are similar with respect to their physicochemical profile as this will have a bearing on whether those analogues partition similarly.</p>
<p>Clicking on the physicochemical profile shows a table and a boxplot of a selection of properties (normalised for the purposes of plotting all on the same figure). The properties are the MW, the number of hydrogen bond donors and acceptors (HBD, HBA) and the log of the octanol/water partition coefficient (logKow). The predictions of these properties are made using the Rcdk package.</p>
<ul>
<li>what can you say about the boxplot with strip plot overlay in terms of the consistency of the source analogues relative to each other and the target substances?</li>
<li>what can you say about the reliability and validity of the physicochemical properties?</li>
</ul>
<p>The table populates if any of the source analogues have physicochemical properties that exceed a three times the standard deviation of any of the properties.</p>
<ul>
<li>Try changing the SMILES and identifier to see if any source analogues fall outside of the threshold.</li>
</ul>
</section>
<section id="read-across-prediction" class="level2">
<h2 class="anchored" data-anchor-id="read-across-prediction">Read-across prediction</h2>
<p>The last tab is updated with the GenRA prediction for the target substance of interest. The pred_act represents the predicted activity score derived by taking the sum of all the pairwise similarities of the source analogues and multiplying them by their LD50_LM value and then dividing this by the sum of the pairwise similarities. This similarity weighted average is effectively taking a mean from the source analogues but adjusting each acute toxicity value by how similar that source analogue is to the target chemical itself. This ensures that an analogue that is not that similar i.e.&nbsp;has a low Tanimoto score is not influencing the toxicity prediction as much as a source analogue that is much more structurally similar.</p>
<p>The pred_act (-1.689) is expressed in a -log molar value.</p>
<p>Take the MW of DTXSID001004378 (210.317) and work out what the LD50 in the usual units of mg/kg are. Is this substance likely to present a high concern for toxicity by the oral route?</p>
<ul>
<li>GHS Classification criteria for acute toxicity categorise substances into 1 of 5 categories based on ranges of LD50 values. Category 5 is an anticipated LD50 between 2000-5000 mg/kg, very low concern whereas Category 1 represents the most severe toxicity with a LD50 equal or less than 5 mg/kg. Category 4 represents the next lowest concern with a range between 300-2000 mg/kg.</li>
</ul>
<p>DTXSID001004378 has a predicted LD50 of 614 mg/kg, which is a predicted Category 4.</p>
</section>
<section id="using-raxr-to-generate-a-prediction" class="level2">
<h2 class="anchored" data-anchor-id="using-raxr-to-generate-a-prediction">Using raxR to generate a prediction</h2>
<p>Minimal packages that are needed are devtools, rcdk, tidyverse, ggplot. To load the functions from raxR, make sure devtools is installed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rcdk)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: rcdklibs</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: rJava</code></pre>
</div>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.2     ✔ tibble    3.2.1
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     </code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter()  masks stats::filter()
✖ dplyr::lag()     masks stats::lag()
✖ dplyr::matches() masks tidyr::matches(), rcdk::matches()
ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(devtools)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: usethis</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load_all</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>ℹ Loading raxR</code></pre>
</div>
</div>
<p>This should load all the functions associated with raxR to facilitate a prediction.</p>
</section>
<section id="preprocessing" class="level2">
<h2 class="anchored" data-anchor-id="preprocessing">Preprocessing</h2>
<p>First load the datasets of interest. These will read in the data files associated with the acute toxicity dataset. Two functions are called from raxR to process the acute toxicity data to harmonise its field names before generate_fingerprints and generate_physchem are used to calculate the chemical fingerprints and physicochemical properties for the source analogues.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>data_path <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">"extdata"</span>, <span class="st">"small_acute_processed.csv"</span>, <span class="at">package =</span> <span class="st">"raxR"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>data_path_1 <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">"extdata"</span>, <span class="st">"smi_acute.csv"</span>, <span class="at">package =</span> <span class="st">"raxR"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>toxicity_data <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(data_path)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>toxicity_data <span class="ot">&lt;-</span> toxicity_data <span class="sc">%&gt;%</span> <span class="fu">select</span>(dtxsid,  LD50_LM)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>source_analogues <span class="ot">&lt;-</span> <span class="fu">process_substances</span>(data_path_1)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>source_FP <span class="ot">&lt;-</span> <span class="fu">generate_fingerprints</span>(source_analogues)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>source_chem <span class="ot">&lt;-</span> <span class="fu">generate_physchem</span>(<span class="fu">generate_mol</span>(source_analogues))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="load-the-target-substance" class="level2">
<h2 class="anchored" data-anchor-id="load-the-target-substance">Load the target substance</h2>
<p>Here the first substance in file ‘targets.csv’, DTXSID001375068, will be used as our target substance of interest. The file will be read and the head function will be used to extract the first substance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>data_path_2 <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">"extdata"</span>, <span class="st">"targets.csv"</span>, <span class="at">package =</span> <span class="st">"raxR"</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>targets <span class="ot">&lt;-</span> <span class="fu">process_substances</span>(data_path_2)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>test_chem <span class="ot">&lt;-</span> <span class="fu">head</span>(targets, <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="generate-the-chemical-fingerprints-for-the-target-substance" class="level2">
<h2 class="anchored" data-anchor-id="generate-the-chemical-fingerprints-for-the-target-substance">Generate the chemical fingerprints for the target substance</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>target_FP <span class="ot">&lt;-</span> <span class="fu">generate_fingerprints</span>(test_chem)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="identify-candidate-analogues" class="level2">
<h2 class="anchored" data-anchor-id="identify-candidate-analogues">Identify candidate analogues</h2>
<p>Here the get_analogues function will be used to find the 10 closest analogues. The function requires the source analogue fingerprints, the target chemical fingerprints and the number of analogues.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>test_analogues <span class="ot">&lt;-</span> <span class="fu">get_analogues</span>(source_FP, target_FP[[<span class="dv">1</span>]], <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Take a look at the top 10 analogues.</li>
</ul>
</section>
<section id="physicochemical-profile-1" class="level2">
<h2 class="anchored" data-anchor-id="physicochemical-profile-1">Physicochemical profile</h2>
<p>Generate the physicochemical profile for the target substance using the generate_physchem function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>target_chem <span class="ot">&lt;-</span> <span class="fu">generate_physchem</span>(<span class="fu">generate_mol</span>(test_chem))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now the physicochemical profile of the target substance will be compared with that of the source analogues. To do that the create_pchem function will be used. This expects the physicochemical information generated for all the source analogues, what the source analogues are for the target substance of interest as well as the target substance’s physicochemical information. Then the prep_df function is used to convert the dataframe generated to a long form to facilitate plotting and for the 3SD threshold to be determined.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>all_pchem <span class="ot">&lt;-</span> <span class="fu">create_pchem</span>(source_chem, test_analogues, target_chem)                   </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>long_pchem <span class="ot">&lt;-</span> <span class="fu">prep_df</span>(all_pchem) </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">filter_sd</span>(long_pchem)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 0 × 7
# ℹ 7 variables: dtxsid &lt;chr&gt;, role &lt;chr&gt;, property &lt;chr&gt;,
#   property_value &lt;dbl&gt;, target_mean &lt;dbl&gt;, target_std &lt;dbl&gt;, outside_sd &lt;lgl&gt;</code></pre>
</div>
</div>
<ul>
<li>Are there any source analogues that exceed the thresholds?</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">add_scale</span>(long_pchem) <span class="sc">%&gt;%</span> <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> property, <span class="at">y =</span> property_scaled)) <span class="sc">+</span> <span class="fu">geom_boxplot</span>(<span class="at">outlier.shape =</span> <span class="cn">NA</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                                                                                        ) <span class="sc">+</span> <span class="fu">geom_jitter</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="raxR_case_study_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="make-read-across-prediction" class="level2">
<h2 class="anchored" data-anchor-id="make-read-across-prediction">Make Read-across prediction</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>with_data <span class="ot">&lt;-</span> test_analogues <span class="sc">%&gt;%</span> <span class="fu">left_join</span>(toxicity_data, <span class="at">by =</span> <span class="st">'dtxsid'</span>) <span class="sc">%&gt;%</span> <span class="fu">drop_na</span>(<span class="st">"LD50_LM"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">wtavg</span>(<span class="at">id =</span> <span class="st">"DTXSID001375068"</span>, with_data, <span class="at">outcome_col =</span> <span class="st">'LD50_LM'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 2
  dtxsid          pred_act
  &lt;chr&gt;              &lt;dbl&gt;
1 DTXSID001375068    -1.69</code></pre>
</div>
</div>
<p>The GenRA prediction was determined to be -1.689 which is a -log molar equivalent. The MW of the target substance is 302.4501. What is the LD50 in mg/kg and what GHS Category does it fall under?</p>
<ul>
<li>The LD50 in mg/kg is 14779, i.e.&nbsp;a category 5, lowest concern level.</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>